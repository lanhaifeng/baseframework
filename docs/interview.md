1.java基础
集合：Set、List、Map
Set:HashSet、LinkedHashSet
List:ArrayList、LinkedList
Map:HashMap、LinkedHashMap、Hashtable

HashMap扩容

字符串：String、StringBuilder、StringBuffer

ThreadLocal源码和设计原理

2.jvm内存结构、调优、垃圾回收机制
内存模型   

程序计数器(线程私有)：
是当前线程锁执行字节码的行号治时期，每条线程都有一个独立的程序计数器，这类内存也称为“线程私有”的内存。正在执行java方法的话，计数器记录的是虚拟机字节码指令的地址(当前指令的地址)。如果是Natice方法，则为空。

java虚拟机栈
也是线程私有的。
每个方法在执行的时候也会创建一个栈帧，存储了局部变量，操作数，动态链接，方法返回地址。
每个方法从调用到执行完毕，对应一个栈帧在虚拟机栈中的入栈和出栈。
通常所说的栈，一般是指在虚拟机栈中的局部变量部分。
局部变量所需内存在编译期间完成分配，
如果线程请求的栈深度大于虚拟机所允许的深度，则StackOverflowError。
如果虚拟机栈可以动态扩展，扩展到无法申请足够的内存，则OutOfMemoryError。

本地方法栈（线程私有）
和虚拟机栈类似，主要为虚拟机使用到的Native方法服务。也会抛出StackOverflowError 和OutOfMemoryError。

Java堆（线程共享）
被所有线程共享的一块内存区域，在虚拟机启动的时候创建，用于存放对象实例。
对可以按照可扩展来实现（通过-Xmx 和-Xms 来控制）
当队中没有内存可分配给实例，也无法再扩展时，则抛出OutOfMemoryError异常。

方法区（线程共享）
被所有方法线程共享的一块内存区域。
用于存储已经被虚拟机加载的类信息，常量，静态变量等。
这个区域的内存回收目标主要针对常量池的回收和堆类型的卸载。

元空间
在JDK 1.8中，HotSpot虚拟机设计团队为了促进HotSpot与 JRockit的融合，修改了方法区的实现，移除了永久代，
并且将原来放在方法区的字符串常量池和静态变量都转移到了Java堆中，选择使用本地化的内存空间(
而不是JVM的内存空间)存放类的元数据，这个空间叫做元空间(Metaspace)。

做了这个改动以后，java.lang.OutOfMemoryError: PermGen的空间问题将不复存在，并且不再需要调整和监控这个内存空间。且虚拟机需要为方法区
设计额外的GC策略：如果类元数据的空间占用达到参数“MaxMetaspaceSize”设置的值，将会触发对死亡对象和类加载器的垃圾回收。为了限制垃圾回收的
频率和延迟，适当的监控和调优元空间是非常有必要的。元空间过多的垃圾收集可能表示类、类加载器内存泄漏或对你的应用程序来说空间太小了。

元空间的内存管理由元空间虚拟机来完成。先前，对于类的元数据我们需要不同的垃圾回收器进行处理，现在只需要执行元空间虚拟机的C++代码即可完成。
在元空间中，类和其元数据的生命周期和其对应的类加载器是相同的。话句话说，只要类加载器存活，其加载的类的元数据也是存活的，因而不会被回收掉。

准确的来说，每一个类加载器的存储区域都称作一个元空间，所有的元空间合在一起就是我们一直说的元
空间。当一个类加载器被垃圾回收器标记为不再存活，其对应的元空间会被回收。在元空间的回收过程中没有重定位和压缩等操作。但是元空间内的元数据
会进行扫描来确定Java引用。

直接内存
直接内存位于本地内存，不属于JVM内存，但是也会在物理内存耗尽的时候报OOM。

在jdk1.4中加入了NIO(New Input/Putput)类，引入了一种基于通道(channel)与缓冲区(buffer)的新IO方式，
它可以使用native函数直接分配堆外内存，然后通过存储在java堆中的DirectByteBuffer对象作为这块内存的引
用进行操作，这样可以在一些场景下大大提高IO性能，避免了在java堆和native堆来回复制数据。

本机直接内存的分配不会受到Java堆大小的限制，但是既然是内存，还是会受到本机总内存(包括RAM以及SWAP区或分页文件)
大小以及处理器寻址空间的限制。服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略
直接内存，使得各个内存区域总和大于物理内存限制(包括物理的和操作系统的限制)，从而导致动态扩展时出现OutOfMemoryError异常。


字符串常量池的设计思想
  1.字符串的分配，和其他的对象分配一样，耗费高昂的时间与空间代价，作为最基础的数据类型，
大量频繁的创建字符串，极大程度地影响程序的性能

  2.JVM为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化
     2.1为字符串开辟一个字符串常量池，类似于缓存区
     2.2创建字符串常量时，首先检测字符串常量池是否存在该字符串
     2.3存在该字符串，返回引用实例，不存在，实例化该字符串并放入池中

  3.实现的基础
     3.1实现该优化的基础是因为字符串是不可变的，可以不用担心数据冲突进行共享
     3.2运行时实时创建的全局字符串常量池中有一个表，总是为池中每个唯一的字符串对象维护一个引用,
        这就意味着它们一直引用着字符串常量池中的对象，所以，在常量池中的这些字符串不会被垃圾收集器回收


垃圾回收机制

垃圾回收算法


垃圾回收器


3.数据索引结构
b-tree、

4.多线程、线程池、锁(悲观、乐观、公平、非公平、独占锁、共享锁)、CAS、AQS
悲观锁：悲观锁，正如其名，具有强烈的独占和排他特性。它指的是对数据被外界(包括本系统当前的其他事务，以及来自外部系统的事务处理)修改持保守态度。因此，在整个数据处理过程中，将数据处于锁定状态

悲观锁主要分为共享锁和排他锁
共享锁【shared locks】又称为读锁，简称S锁。顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。
排他锁【exclusive locks】又称为写锁，简称X锁。顾名思义，排他锁就是不能与其他锁并存，如果一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据行读取和修改

悲观锁的实现
1.传统的关系型数据库使用这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁
2.Java里面的同步synchronized关键字的实现

乐观锁：乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。乐观锁适用于读操作多的场景，这样可以提高程序的吞吐量

乐观锁的实现
1.CAS 实现：Java 中java.util.concurrent.atomic包下面的原子变量使用了乐观锁的一种CAS实现方式
2.版本控制：一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数。当数据被修改时，version 值会+1。
当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值与当前数据库中的version值相等时才更新，
否则重试更新操作，直到更新成功

CAS的ABA问题：
1.比如说线程一从数据库中取出库存数 3，这时候线程二也从数据库中取出库存数 3，并且线程二进行了一些操作变成了 2。
2.然后线程二又将库存数变成 3，这时候线程一进行CAS操作发现数据库中仍然是 3，然后线程一操作成功。
3.尽管线程一的 CAS 操作成功，但是不代表这个过程就是没有问题的
一个比较好的解决办法，就是通过一个单独的可以顺序递增的version字段


AQS原理


Synchronized原理、优化、锁膨胀

原理
JVM 是通过进入、退出对象监视器(Monitor)来实现对方法、同步块的同步的，而对象监视器的本质依赖于底层
操作系统的互斥锁(Mutex Lock)实现。

具体实现是在编译之后在同步方法调用前加入一个monitor.enter指令，在退出方法和异常处插入monitor.exit
的指令。

对于没有获取到锁的线程将会阻塞到方法入口处，直到获取锁的线程monitor.exit之后才能尝试继续获取锁。

同步块的入口和出口分别有monitorenter和monitorexit指令。当执行monitorenter指令时，线程试图获取
锁也就是获取monitor（monitor对象存在于每个Java对象的对象头中，synchronized锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因）的持有权。当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行monitorexit指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。

在synchronized修饰方法时是添加ACC_SYNCHRONIZED标识，该标识指明了该方法是一个同步方法，JVM通过该
ACC_SYNCHRONIZED访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用

Synchronized属性
（1）原子性：确保线程互斥的访问同步代码；
为什么volatile已经保证了变量的可见性，synchronized依然保证变量的可见性：
（2）可见性：保证共享变量的同步能够及时可见，通过JMM模型：“对一个共享变量unlock（解锁）之前一定要先同步到主内存中；如果要是对一个共享变量进行lock（锁定）的之前一定要清除工作内存中的值，然后通过主内存中的值加载到工作内存中”；
（3）有序性：有效解决重排序问题，即 “一个unlock操作先行发生(happen-before)于后面对同一个锁的lock操作”；

https://blog.csdn.net/weixin_36759405/article/details/83034386


5.高并发
垂直扩展：提升单机处理能力
5.1增强单机硬件性能，例如：增加CPU核数如32核，升级更好的网卡如万兆，升级更好的硬盘如SSD，扩充硬盘容量如2T，扩充系统内存如128G；
5.2提升单机架构性能，例如：使用Cache来减少IO次数，使用异步来增加单服务吞吐量，使用无锁数据结构来减少响应时间；


水平扩展：只要增加服务器数量，就能线性扩充系统性能。水平扩展对系统架构设计是有要求的，如何在架构各层进行可水平扩展的设计，以及互联网公司架构各层常见的水平扩展实践，是本文重点讨论的内容
nginx分流+集群

6.分布式、集群
分布式事务锁

7.高可用

8.sql优化分库、分表
cpu瓶颈：索引优化sql、单表数据太大水平分表
磁盘IO瓶颈：热点数据太多，数据库缓存放不下，每次查询时会产生大量的IO，降低查询速度 -> 分库和垂直分表
网络IO瓶颈：请求的数据太多，网络带宽不够 -> 分库

索引时
1.insert变慢
2.select正常走索引变快
3.update，如果set索引字段变慢，如果where走索引变快
4.delete要看where条件后走索引节省的时间与删除索引花费时间的差值了

水平
场景：系统绝对并发量上来了，分表难以根本上解决问题，并且还没有明显的业务归属来垂直分库
水平分库：以字段为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中

场景：系统绝对并发量并没有上来，只是单表的数据量太多，影响了SQL效率，加重了CPU负担，以至于成为瓶颈
水平分表：以字段为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中。


垂直
场景：系统绝对并发量上来了，并且可以抽象出单独的业务模块。
垂直分库：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中

场景：系统绝对并发量并没有上来，表的记录并不多，但是字段多，并且热点数据和非热点数据在一起，单行数据所需的存储空间较大。以至于数据库缓存的数据行减少，查询时会去读磁盘数据产生大量的随机读IO，产生IO瓶颈
垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中


https://zhuanlan.zhihu.com/p/137368446

9.http、https、证书、对称加密、非对称加密
+ 私钥加密、签名，公钥解密、验证签名
+ 证书可靠性保证：
  1.是否信任根证书链
  2.认为根证书私钥不会泄露
  3.用根证书的公钥验证权威机构颁发证书签名（即权威机构用私钥加密证书摘要算法的内容是否能被根证书公钥解密）
  
  
10.API序列化与反序列化
  jackson忽略字段的三种方式：
    1.@JsonIgnore
    2.@JsonIgnoreProperties
    3.@JsonIgnoreType
        
  动态过滤字段：@JsonFilter("myFilter")+过滤器
  
  条件序列化：自定义序列化类(extends JsonSerializer)