1.java基础
集合：Set、List、Map
Set:HashSet、LinkedHashSet
List:ArrayList、LinkedList
Map:HashMap、LinkedHashMap、Hashtable


字符串：String、StringBuilder、StringBuffer

2.jvm内存结构、调优、垃圾回收机制

3.数据索引结构
b-tree、

4.多线程、线程池、锁(悲观、乐观、公平、非公平、独占锁、共享锁)、CAS、AQS
悲观锁：悲观锁，正如其名，具有强烈的独占和排他特性。它指的是对数据被外界(包括本系统当前的其他事务，以及来自外部系统的事务处理)修改持保守态度。因此，在整个数据处理过程中，将数据处于锁定状态

悲观锁主要分为共享锁和排他锁
共享锁【shared locks】又称为读锁，简称S锁。顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。
排他锁【exclusive locks】又称为写锁，简称X锁。顾名思义，排他锁就是不能与其他锁并存，如果一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据行读取和修改

悲观锁的实现
1.传统的关系型数据库使用这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁
2.Java里面的同步synchronized关键字的实现

乐观锁：乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。乐观锁适用于读操作多的场景，这样可以提高程序的吞吐量

乐观锁的实现
1.CAS 实现：Java 中java.util.concurrent.atomic包下面的原子变量使用了乐观锁的一种CAS实现方式
2.版本控制：一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数。当数据被修改时，version 值会+1。
当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值与当前数据库中的version值相等时才更新，
否则重试更新操作，直到更新成功

CAS的ABA问题：
1.比如说线程一从数据库中取出库存数 3，这时候线程二也从数据库中取出库存数 3，并且线程二进行了一些操作变成了 2。
2.然后线程二又将库存数变成 3，这时候线程一进行CAS操作发现数据库中仍然是 3，然后线程一操作成功。
3.尽管线程一的 CAS 操作成功，但是不代表这个过程就是没有问题的
一个比较好的解决办法，就是通过一个单独的可以顺序递增的version字段




5.高并发
垂直扩展：提升单机处理能力
5.1增强单机硬件性能，例如：增加CPU核数如32核，升级更好的网卡如万兆，升级更好的硬盘如SSD，扩充硬盘容量如2T，扩充系统内存如128G；
5.2提升单机架构性能，例如：使用Cache来减少IO次数，使用异步来增加单服务吞吐量，使用无锁数据结构来减少响应时间；


水平扩展：只要增加服务器数量，就能线性扩充系统性能。水平扩展对系统架构设计是有要求的，如何在架构各层进行可水平扩展的设计，以及互联网公司架构各层常见的水平扩展实践，是本文重点讨论的内容
nginx分流+集群

6.分布式、集群

7.高可用

8.sql优化分库、分表
cpu瓶颈：索引优化sql、单表数据太大水平分表
磁盘IO瓶颈：热点数据太多，数据库缓存放不下，每次查询时会产生大量的IO，降低查询速度 -> 分库和垂直分表
网络IO瓶颈：请求的数据太多，网络带宽不够 -> 分库

水平
场景：系统绝对并发量上来了，分表难以根本上解决问题，并且还没有明显的业务归属来垂直分库
水平分库：以字段为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中

场景：系统绝对并发量并没有上来，只是单表的数据量太多，影响了SQL效率，加重了CPU负担，以至于成为瓶颈
水平分表：以字段为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中。


垂直
场景：系统绝对并发量上来了，并且可以抽象出单独的业务模块。
垂直分库：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中

场景：系统绝对并发量并没有上来，表的记录并不多，但是字段多，并且热点数据和非热点数据在一起，单行数据所需的存储空间较大。以至于数据库缓存的数据行减少，查询时会去读磁盘数据产生大量的随机读IO，产生IO瓶颈
垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中


https://zhuanlan.zhihu.com/p/137368446